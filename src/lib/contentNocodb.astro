
---
import { api } from './api/nocodb';

interface PageInfo {
  totalRows: number;
  page: number;
  pageSize: number;
  totalPages: number;
}

interface ApiResponse {
  list: any[];
  pageInfo: PageInfo;
}

// File d'attente pour les requêtes
class RequestQueue {
  private queue: Array<{
    resolve: (value: any) => void;
    reject: (reason?: any) => void;
    fn: () => Promise<any>;
  }> = [];
  private processing = false;
  private lastRequestTime = 0;
  private minRequestInterval = 200; // 200ms entre les requêtes = 5 requêtes/seconde max

  async enqueue<T>(fn: () => Promise<T>): Promise<T> {
    return new Promise((resolve, reject) => {
      this.queue.push({
        resolve,
        reject,
        fn
      });
      
      if (!this.processing) {
        this.processQueue();
      }
    });
  }

  private async processQueue() {
    if (this.queue.length === 0) {
      this.processing = false;
      return;
    }

    this.processing = true;
    const now = Date.now();
    const timeToWait = Math.max(0, this.lastRequestTime + this.minRequestInterval - now);

    if (timeToWait > 0) {
      await new Promise(resolve => setTimeout(resolve, timeToWait));
    }

    const request = this.queue.shift()!;

    try {
      this.lastRequestTime = Date.now();
      const result = await request.fn();
      request.resolve(result);
    } catch (error) {
      request.reject(error);
    } finally {
      // Continuer avec la prochaine requête
      setTimeout(() => this.processQueue(), 0);
    }
  }
}

const requestQueue = new RequestQueue();

export const getData = async (tableId: string, query: object = {}) => {
  try {
    return await requestQueue.enqueue(() => 
      api.get(`/api/v2/tables/${tableId}/records`, { params: query })
        .then(response => response.data)
    );
  } catch (error) {
    console.error('Error fetching data:', error);
    throw error;
  }
};

export const getAll = async (tableId: string, query: object = {}) => {
  try {
    let allRecords = [];
    let page = 1;
    let totalRows = 0;
    const baseParams = {
      viewId: query?.viewId,
      fields: query?.fields,
      where: query?.where
    };
    
    // Première requête pour obtenir le nombre total d'enregistrements
    const firstResponse = await requestQueue.enqueue(() => 
      api.get(`/api/v2/tables/${tableId}/records`, {
        params: {
          ...baseParams,
          limit: 100,
          page: 1
        }
      })
    );
    
    const firstData = firstResponse.data as ApiResponse;
    if (!firstData.pageInfo) {
      throw new Error('Format de réponse API invalide : pageInfo manquant');
    }
    
    totalRows = firstData.pageInfo.totalRows;
    allRecords = [...firstData.list];
    
    // Calcul du nombre total de pages
    const totalPages = Math.ceil(totalRows / 100);
    
    // Récupération des pages restantes
    const pagePromises = [];
    
    for (let p = 2; p <= totalPages; p++) {
      pagePromises.push(
        requestQueue.enqueue(() => 
          api.get(`/api/v2/tables/${tableId}/records`, {
            params: {
              ...baseParams,
              limit: 100,
              page: p
            }
          })
          .then(response => {
            const data = response.data as ApiResponse;
            if (!data.list) {
              throw new Error(`Format de réponse API invalide pour la page ${p}`);
            }
            return data.list;
          })
        )
      );
    }
    
    // Attendre que toutes les requêtes soient terminées
    const results = await Promise.all(pagePromises);
    
    // Combiner tous les résultats
    for (const result of results) {
      allRecords = [...allRecords, ...result];
    }
    
    return {
      list: allRecords,
      total: allRecords.length,
      pageInfo: {
        totalRows,
        totalPages,
        pageSize: 100
      }
    };
    
  } catch (error) {
    console.error('Erreur lors de la récupération de toutes les données:', error);
    throw error;
  }
};

---
